# Detail: Dependencies and YAML Breakdown

This document explains:
1. What dependencies are installed in this project and why they are used.
2. What each YAML/YML file contains and why it is required.

---

## 1) Dependencies installed and why they are used

## 1.1 Backend Python dependencies (`backend/requirements.txt`)

| Dependency | Why it is used |
|---|---|
| `fastapi` | Web framework for the REST API. |
| `uvicorn[standard]` | ASGI server used to run FastAPI in dev/prod containers. |
| `pydantic` | Request/response data validation and schema enforcement. |
| `pydantic-settings` | Loads env-based configuration into strongly typed settings. |
| `SQLAlchemy` | ORM and SQL toolkit for database access and models. |
| `psycopg2-binary` | PostgreSQL DB driver used by SQLAlchemy. |
| `alembic` | Database migration tool used for schema versioning. |
| `redis` | Redis client used for cache access and queue backend communication. |
| `celery` | Background job worker framework for async order processing. |
| `python-jose[cryptography]` | JWT token encode/decode and signature verification. |
| `passlib[bcrypt]` | Password hashing and verification abstraction. |
| `bcrypt` | Hash algorithm backend used by passlib. |
| `python-multipart` | Required for form-based login payload parsing (`OAuth2PasswordRequestForm`). |
| `email-validator` | Needed by `EmailStr` for email format validation in Pydantic. |
| `prometheus-fastapi-instrumentator` | Exposes FastAPI metrics at `/metrics`. |
| `python-json-logger` | Structured JSON logs for observability pipelines (Loki-ready labels). |
| `pytest` | Unit/integration testing framework. |
| `httpx` | HTTP client used in tests and request-level checks. |
| `ruff` | Fast linter used in CI and local quality checks. |

## 1.2 OS/runtime packages used by backend Docker image

| Package | Where | Why it is used |
|---|---|---|
| `build-essential` | Docker builder stage | Compilers/toolchain for building Python wheels. |
| `gcc` | Docker builder stage | Native compilation support for some Python packages. |
| `libpq-dev` | Docker builder stage | PostgreSQL client headers/libs for build time. |
| `libpq5` | Docker runtime stage | PostgreSQL runtime shared libraries. |
| `curl` | Docker runtime stage | Healthcheck command to test app liveness endpoint. |

## 1.3 Service images used by infrastructure

| Component | Image |
|---|---|
| PostgreSQL | `postgres:16-alpine` |
| Redis | `redis:7-alpine` |
| Frontend web server | `nginx:1.27-alpine` |
| Prometheus | `prom/prometheus:v2.55.1` |
| Grafana | `grafana/grafana:11.4.0` |
| CI docker executor image | `docker:27.4.0` (+ `docker:dind`) |
| CI kubectl deploy image | `bitnami/kubectl:1.31` |

---

## 2) YAML/YML files explained (what is inside + why required)

## 2.1 Local runtime orchestration

### `docker-compose.yml`
- Contains:
  - `postgres` service with healthcheck and persistent volume.
  - `redis` service with AOF persistence and healthcheck.
  - `backend` service that runs migrations, seeds data, then starts API.
  - `worker` service that starts Celery.
  - `frontend` service served by Nginx.
  - Named volumes: `postgres_data`, `redis_data`.
- Why required:
  - Gives one-command local environment for full-stack testing (`docker compose up`).
  - Mimics production dependencies locally.

## 2.2 CI/CD pipelines

### `cicd/github-actions.yaml`
- Contains:
  - `lint-test` job (`ruff`, `pytest`).
  - `build-and-push` job for backend/frontend images with `sha` and `latest` tags.
  - `deploy` job applying K8s manifests and setting image tags on deployments.
- Why required:
  - Automates quality gates and delivery on GitHub.
  - Enforces repeatable deployment workflow.

### `cicd/gitlab-ci.yaml`
- Contains:
  - Pipeline stages: `lint`, `test`, `build`, `deploy`.
  - Docker-in-Docker image builds and registry pushes.
  - Kubernetes deploy + rollout status checks.
- Why required:
  - GitLab equivalent CI/CD for teams not using GitHub Actions.
  - Supports same promotion path in alternate CI platform.

## 2.3 Kubernetes namespace and RBAC

### `k8s/namespaces/namespace.yaml`
- Contains:
  - `Namespace` named `k8s-learning`.
- Why required:
  - Logical isolation for all app resources.
  - Easier RBAC, cleanup, and environment scoping.

### `k8s/rbac/backend-rbac.yaml`
- Contains:
  - `ServiceAccount` (`backend-sa`).
  - `Role` allowing read/list/watch for configmaps, secrets, pods.
  - `RoleBinding` attaching role to service account.
- Why required:
  - Principle of least privilege for backend and worker pods.
  - Explicit identity + permissions for workload access.

## 2.4 Backend Kubernetes resources

### `k8s/backend/configmap.yaml`
- Contains:
  - Non-sensitive backend env vars (`PROJECT_NAME`, `API_PREFIX`, `LOG_LEVEL`, etc.).
- Why required:
  - Externalizes configuration from container images.
  - Enables environment-specific config without rebuilding images.

### `k8s/backend/secret.yaml`
- Contains:
  - Base64-encoded sensitive values (`SECRET_KEY`, DB/Redis URLs, DB credentials).
- Why required:
  - Keeps secrets separate from plain config.
  - Used by backend and DB workloads through `envFrom` / `secretKeyRef`.

### `k8s/backend/deployment.yaml`
- Contains:
  - `Deployment` for API pods.
  - `replicas: 3`, rolling update strategy, revision history.
  - `initContainer` running `alembic upgrade head`.
  - Main container with probes (`/health/live`, `/health/ready`), resource requests/limits.
  - Pod security context (`runAsNonRoot`, no privilege escalation).
- Why required:
  - Runs and manages stateless backend API replicas.
  - Handles rolling updates, resiliency, and startup migration step.

### `k8s/backend/worker-deployment.yaml`
- Contains:
  - `Deployment` for Celery workers (`replicas: 2`).
  - Worker command, probes via process check (`pgrep -f celery`).
  - Resource requests/limits.
- Why required:
  - Offloads long-running/async work from API.
  - Allows independent scaling of background processing tier.

### `k8s/backend/service.yaml`
- Contains:
  - `ClusterIP` service mapping port `80` to backend pod port `8000`.
- Why required:
  - Stable internal DNS endpoint for backend (`backend-service`).
  - Used by Ingress and Prometheus target.

### `k8s/backend/hpa.yaml`
- Contains:
  - `HorizontalPodAutoscaler` targeting `backend-api` deployment.
  - CPU target utilization `70%`, min replicas `2`, max `10`.
- Why required:
  - Auto-scales backend under load.
  - Controls cost/performance using CPU-based scaling.

## 2.5 Frontend Kubernetes resources

### `k8s/frontend/deployment.yaml`
- Contains:
  - `Deployment` for frontend Nginx pods with readiness/liveness probes.
  - Resource requests/limits.
- Why required:
  - Serves static SPA assets in replicated, managed pods.

### `k8s/frontend/service.yaml`
- Contains:
  - `NodePort` service exposing frontend on `30080`.
- Why required:
  - Provides simple external access without ingress in basic setups.
  - Still usable as Ingress backend service.

## 2.6 PostgreSQL Kubernetes resources

### `k8s/postgres/pvc.yaml`
- Contains:
  - `PersistentVolumeClaim` (`10Gi`, `ReadWriteOnce`).
- Why required:
  - Persists DB data across pod restarts/recreation.

### `k8s/postgres/service.yaml`
- Contains:
  - Headless service (`clusterIP: None`) for StatefulSet identity.
- Why required:
  - Stable network identity for StatefulSet-managed DB pod(s).

### `k8s/postgres/statefulset.yaml`
- Contains:
  - `StatefulSet` with 1 postgres replica.
  - Secret-based DB env vars.
  - Mounted persistent volume from PVC.
  - Readiness/liveness probes using `pg_isready`.
  - Resource requests/limits.
- Why required:
  - Correct pattern for stateful DB lifecycle and stable storage attachment.

## 2.7 Redis Kubernetes resources

### `k8s/redis/deployment.yaml`
- Contains:
  - `Deployment` running Redis with AOF enabled.
  - TCP readiness/liveness probes.
  - Resource requests/limits.
- Why required:
  - Provides cache and Celery broker/backend functionality.
  - Health probes improve failure detection.

### `k8s/redis/service.yaml`
- Contains:
  - `ClusterIP` service exposing Redis port `6379`.
- Why required:
  - Stable internal endpoint for backend and worker connectivity.

## 2.8 Ingress

### `k8s/ingress/ingress.yaml`
- Contains:
  - NGINX `Ingress` for host `app.local`.
  - Path routing:
    - `/api` -> `backend-service`
    - `/` -> `frontend-service`
  - Annotation for max proxy body size.
- Why required:
  - Single external entrypoint with path-based routing.
  - Cleaner client access than direct NodePort usage.

## 2.9 Monitoring stack

### `k8s/monitoring/prometheus.yaml`
- Contains:
  - `ConfigMap` with scrape config for backend `/metrics`.
  - `Deployment` running Prometheus with mounted config.
  - `Service` (`NodePort 30900`) for UI access.
- Why required:
  - Collects time-series metrics from API.
  - Powers dashboarding and alerting pipelines.

### `k8s/monitoring/grafana.yaml`
- Contains:
  - `Secret` for Grafana admin credentials.
  - `ConfigMap` for Prometheus datasource provisioning.
  - `ConfigMap` dashboard provider config.
  - `ConfigMap` with preloaded orders dashboard JSON.
  - `Deployment` mounting all provisioning files.
  - `Service` (`NodePort 30300`) for Grafana UI.
- Why required:
  - Visualizes Prometheus metrics with ready dashboards.
  - Auto-provisioned setup avoids manual UI configuration.

---

## 3) Quick note about health endpoints and probes

- API liveness endpoint: `/health/live`
- API readiness endpoint: `/health/ready`
- Metrics endpoint: `/metrics`

Probe usage in YAML:
- `backend/deployment.yaml` uses HTTP readiness/liveness probes.
- `frontend/deployment.yaml` uses HTTP probes on `/`.
- `postgres/statefulset.yaml` uses `pg_isready`.
- `redis/deployment.yaml` uses TCP probes.
- `backend/worker-deployment.yaml` uses process-existence exec probe.

